Rapport d'expertise sur la gestion du focus des fenêtres gtk4-rs transitoires sous le compositeur HyprlandI. Introduction : Déconstruction de la désynchronisation du focus entre Hyprland et GTK4La requête soumise concerne une difficulté fondamentale dans le développement d'applications natives Wayland utilisant gtk4-rs lorsqu'elles sont exécutées sous le gestionnaire de fenêtres Hyprland. L'utilisateur cherche à implémenter un comportement standard de l'interface graphique : la création d'une fenêtre superposée (un menu ou un popover) qui se ferme automatiquement lorsque l'utilisateur clique en dehors de celle-ci, ou lorsque le focus est déplacé ailleurs. Cette fonctionnalité, essentielle pour les éléments modaux et contextuels, est systématiquement brisée par la politique de gestion du focus d'Hyprland.1.1 Contextualisation du Problème : L'illusion de la modalité dans HyprlandLe cœur du problème réside dans un conflit architectural entre le contrat du protocole Wayland, tel qu'interprété par la boîte à outils GTK4, et les politiques de gestion d'entrée par défaut d'Hyprland. Les applications GTK4 mettent en œuvre un comportement modal standard, qui suppose que le compositeur respecte les saisies d'entrée (focus grabs) nécessaires pour les éléments transitoires.1 Cependant, Hyprland privilégie une gestion agressive du focus suivant la souris, souvent définie par l'option input:follow_mouse supérieure à zéro.2L'effet immédiat de cette politique agressive est que le suivi de focus d'Hyprland, basé sur la géométrie du curseur, anticipe et contourne la saisie de pointeur/clavier requise par l'application GTK pour maintenir l'état modal. Lorsqu'un popover est affiché, il tente d'établir un grab de focus. Si le curseur quitte la zone du popover pour survoler la fenêtre parente sous-jacente, Hyprland, interprétant ce mouvement comme un signal de changement de focus, retire le focus du popover et le donne à la fenêtre parente.La conséquence la plus grave de ce comportement n'est pas seulement l'échec de la fermeture automatique du menu, mais l'induction d'un état de "verrouillage" ou de désynchronisation de l'entrée. Les rapports de la communauté confirment qu'après l'ouverture d'un menu contextuel GTK en Wayland, la fenêtre d'arrière-plan peut devenir "verrouillée" (non réceptive aux clics).4 Cela se produit car le clic que l'utilisateur destine à être un événement de "clic externe" (qui devrait fermer le menu via le grab modal) est, au lieu de cela, livré à la fenêtre parente qui vient de recevoir le focus de manière inattendue, tandis que l'application GTK est toujours en attente de la libération du grab par le popover. Cette situation critique nécessite une intervention à deux niveaux : l'application (Rust/GTK4) et la politique du compositeur (Hyprland).1.2 Structure du rapport et stratégie de solutionLa résolution de ce problème technique nécessite une compréhension détaillée de la manière dont les surfaces transitoires sont gérées par le protocole Wayland et de la manière dont les surcharges de configuration d'Hyprland peuvent être exploitées pour restaurer le comportement protocolaire attendu. Ce rapport déploiera une solution holistique, divisée en une analyse du contrat protocolaire, un diagnostic de la défaillance, et enfin, la mise en œuvre de solutions robustes côté client (gtk4-rs) et côté compositeur (hyprland.conf).II. Le contrat protocolaire Wayland/GTK4 : surfaces transitoires et saisiesPour comprendre l'échec sous Hyprland, il est essentiel de définir comment GTK4 implémente les fenêtres transitoires conformément au protocole Wayland.2.1 Définition du comportement transitoire WaylandLe protocole xdg-shell est la pierre angulaire de la gestion des fenêtres transitoires sur Wayland. Il définit deux types principaux de surfaces : xdg_toplevel pour les fenêtres principales (qui peuvent avoir des parents transitoires) et xdg_popup pour les éléments éphémères comme les menus, les info-bulles et les dialogues modaux.La boîte à outils GTK4, via son backend Wayland, encapsule cette logique. Le type GdkWaylandPopup est l'implémentation spécifique Wayland d'une surface gdk::Popup.5 Le système Wayland attend du compositeur qu'il honore la relation transitoire définie, garantissant que le popup enfant soit affiché logiquement au-dessus de son parent et qu'il gère les entrées de manière appropriée.Il est important de noter que GTK4 prend également en charge des mécanismes plus avancés pour les relations transitoires entre processus, comme set_transient_for_exported. Cette fonction permet de lier une surface à une autre surface dont le handle a été exporté depuis un processus différent.6 Bien que non directement impliqué dans le problème simple du menu local, ce mécanisme souligne la complexité et la robustesse que le Wayland shell exige pour la gestion des relations de surface.2.2 Mécanisme canonique de GTK4 pour la fermeture automatiqueL'implémentation correcte de la fonctionnalité souhaitée par l'utilisateur (un menu qui se ferme lors d'un clic externe) dans gtk4-rs passe par l'utilisation du widget dédié : GtkPopover.Le GtkPopover est conçu spécifiquement pour présenter des popups en forme de bulle, destinés à fournir des informations ou des options contextuelles.7 Par défaut, un GtkPopover exécute une saisie (grab) pour garantir que les événements d'entrée lui sont redirigés tant qu'il est affiché. Cette saisie est la clé de la détection de la démodalisation.L'API critique pour l'utilisateur est PopoverExt::set_autohide(true).1L'activation de la propriété autohide a plusieurs effets vitaux pour le comportement modal :Le popover devient modal et saisit le focus clavier.Le focus reste circonscrit au popover (le focus tourne à l'intérieur).Le popover se ferme lorsque l'utilisateur clique en dehors de sa zone ou appuie sur la touche Échap.1La fermeture par clic externe dépend entièrement du succès de la saisie de focus initiale. Le compositeur est censé maintenir cette saisie tant que le popover est actif. Si Hyprland ne respecte pas le grab de focus et redirige instantanément le focus vers le parent dès que le curseur se déplace (en raison de follow_mouse), le mécanisme de modalité de GTK est rompu, et la détection du clic externe comme événement de fermeture échoue. Le clic est alors traité comme un événement destiné à la fenêtre parente nouvellement (et incorrectement) focalisée.III. Diagnostic : Comment Hyprland perturbe l'intégrité du focusL'analyse de la cause première du problème révèle que Hyprland, dans ses configurations par défaut ou populaires, introduit une instabilité de focus qui entre en collision directe avec les attentes protocolaires de GTK4.3.1 Le rôle de input:follow_mouse dans le vol de focusLes politiques de focus d'Hyprland sont gérées principalement par la variable input:follow_mouse.Valeur follow_mouseDescription0Le mouvement du curseur ne change pas le focus (comportement de WM de carrelage standard).1Le mouvement du curseur change le focus de manière agressive (source fréquente de problèmes).2Le focus du curseur est détaché du focus clavier ; le focus clavier ne change qu'au clic.3Même en utilisant le réglage le plus modéré pour l'entrée basée sur le curseur, à savoir follow_mouse = 2, les problèmes persistent. Il est documenté dans la communauté Hyprland que les fenêtres flottantes, y compris les dialogues "Enregistrer sous..." ou les popups d'applications comme Krita ou SpeedCrunch, ne respectent pas cette règle.3 Lorsqu'un dialogue est ouvert, le simple fait de déplacer la souris sur la fenêtre parente sous-jacente entraîne le transfert du focus vers le parent, même sans clic. Cela contredit l'intention de l'application et la documentation Hyprland elle-même pour le mode 2.Cette défaillance met en évidence un défaut de conception dans la manière dont Hyprland gère les surfaces transitoires (xdg_popup ou fenêtres marquées comme modales/transitoires) par rapport à sa politique de suivi de la souris. Le gestionnaire de fenêtres semble donner la priorité à sa propre logique géométrique de suivi du curseur sur le grab de focus établi par le client (l'application GTK), conduisant à la défaillance du mécanisme de fermeture automatique.3.2 Le symptôme : Verrouillage de l'entrée et persistance du menuLe résultat de cette préemption du focus est l'état de "verrouillage" mentionné par l'utilisateur.Des rapports de régression spécifiques confirment que, dans les applications GTK natives Wayland, l'ouverture d'un menu contextuel (tel que dans Firefox ou Seahorse) empêche non seulement la fermeture par clic externe, mais rend également la fenêtre d'arrière-plan non réactive.4 Le gestionnaire de fenêtres indique que la fenêtre parent est focalisée, mais l'application GTK est bloquée en attendant la libération du grab modal qui n'arrive jamais.Théoriquement, la cause est une désynchronisation d'entrée. Hyprland déplace le focus (visuel et clavier) vers le parent basé sur la géométrie du curseur, mais le popover GTK conserve une saisie de pointeur logique (le grab), ce qui empêche le parent de traiter correctement les entrées. Le clic qui devrait être un signal de libération du grab est, au lieu de cela, livré comme un clic normal à la fenêtre parent qui est maintenant active, sans pour autant libérer le grab du popover. Une réinitialisation violente de l'état de focus (comme changer d'espace de travail ou basculer le focus) est souvent la seule façon de déverrouiller l'entrée.43.3 Contribution des politiques de focus : general:no_focus_fallbackBien que n'étant pas une solution directe au problème des popups, l'utilisation de general:no_focus_fallback = true dans la configuration Hyprland est recommandée pour améliorer la stabilité générale du focus.2 Ce paramètre empêche le focus de se "repiquer" ou de s'enrouler vers la fenêtre la plus éloignée lorsqu'un mouvement de focus clavier (par exemple, Super+Flèche) ne trouve pas de fenêtre dans la direction demandée. L'activation de ce paramètre contribue à un environnement de focus moins chaotique et moins susceptible d'interférer avec les événements de démodalisation.La persistance de ce problème, même avec des tentatives de configuration d'entrée plus douces (comme follow_mouse = 2), démontre que le compositeur nécessite une intervention manuelle spécifique pour traiter correctement les surfaces transitoires. L'unique solution restante est l'utilisation des surcharges de politique les plus puissantes d'Hyprland : les règles de fenêtre ciblées (windowrulev2).IV. Implémentation Côté Client : Conception robuste d'overlay GTK4-RSL'approche la plus stable côté application Rust/GTK4 consiste à utiliser le widget GtkPopover comme prévu, en s'assurant que l'intention de modalité est clairement communiquée au compositeur.4.1 Utilisation du GtkPopover CanoniqueL'utilisation de GtkPopover est la méthode privilégiée par GTK pour les menus contextuels, car il gère en interne la logique de saisie et de fermeture.L'initialisation d'un popover dans gtk4-rs et son attachement à un widget parent (GtkWidgetExt) est la première étape. L'étape critique pour le comportement de fermeture automatique est l'appel de la méthode qui signale l'intention de modalité :Rust// Exemple conceptuel en Rust/gtk4-rs
let popover = gtk4::Popover::new();
//... ajouter des enfants au popover...

// CRITIQUE : Définit le comportement modal et la fermeture au clic externe
popover.set_autohide(true); 

// Lier le popover à un widget
// popover.set_parent(Some(&parent_widget)); 

// Afficher le popover
popover.present(); 
Il est essentiel de s'assurer que popover.set_autohide(true) est appelé. De plus, bien que le GtkPopover soit implicitement modal par défaut et gère l'autohide, la propriété autohide doit être explicitement définie à true.1 C'est ce signal d'intention de saisie d'entrée qui doit être préservé par Hyprland.4.2 L'approche alternative : Gestion manuelle de la perte de focusPour les développeurs qui choisissent d'utiliser une GtkWindow personnalisée et transitoire au lieu d'un GtkPopover standard, une détection manuelle de la perte de focus est requise. Cela impliquerait de se connecter à des signaux de focus, comme ceux liés à l'état is-active de la fenêtre 10 ou aux événements de surface GDK sous-jacents.Si le focus est perdu (c'est-à-dire que la propriété is_active devient fausse), l'application devrait manuellement demander la fermeture de la fenêtre transitoire en appelant window.close().11 Cependant, cette approche est intrinsèquement instable sous Hyprland. En raison de la vitesse et de l'agressivité avec lesquelles le compositeur peut voler et potentiellement restaurer le focus (flicker) basé sur le mouvement du curseur, l'application peut manquer l'état de perte de focus ou réagir trop tard, conduisant à la même instabilité. Pour une solution robuste, le GtkPopover couplé à la configuration Hyprland est la voie privilégiée.4.3 Identification de la classe de fenêtre pour le ciblage du compositeurAvant d'appliquer des règles d'Hyprland, il est indispensable de connaître la classe ou le titre exact de la fenêtre du popup. Pour les applications personnalisées, cela est contrôlé par le développeur. Pour les menus internes ou les dialogues génériques, cela peut être plus complexe.La procédure standard consiste à utiliser l'utilitaire hyprctl clients immédiatement après l'apparition du popup. Cela permet de capturer la chaîne de caractères exacte de la class ou du title de la fenêtre transitoire, qui sera utilisée comme expression régulière de ciblage dans hyprland.conf.12 Dans certains cas de popups génériques, il peut être nécessaire de cibler les portails XDG, comme xdg-desktop-portal-gtk.12L'implémentation GTK4 fournit l'intention de modalité (set_autohide). Cependant, en présence d'un compositeur Wayland qui ne respecte pas l'intégralité de cette intention dans le cadre d'une saisie de pointeur, il est nécessaire d'utiliser les outils du compositeur (windowrulev2) pour forcer le respect de cette intention. La solution est donc une synergie obligatoire : l'application fournit le signal, et Hyprland fournit l'application de la politique via une surcharge.V. Atténuation Côté Compositeur : Surcharges de configuration HyprlandLe remède le plus fiable pour corriger le comportement des popups GTK4 sous Hyprland est l'application de règles de fenêtre spécifiques qui neutralisent les politiques agressives de gestion du focus.5.1 Configuration globale pour la stabilité du focusPour minimiser les conflits, il est fortement recommandé d'ajuster les paramètres d'entrée généraux d'Hyprland.Le réglage le plus stable pour follow_mouse est 0, qui désactive le changement de focus basé sur le mouvement du curseur.2De plus, l'activation de general:no_focus_fallback = true prévient les changements de focus imprévus lors de la navigation au clavier.2Tableau 1 : Variables de configuration Hyprland critiques pour la stabilité du focus GTKVariableBlocRéglage RecommandéRaisonnement pour les Popups GTKSourcefollow_mouseinput0 (ou 2 avec stayfocused)Empêche le vol de focus lorsque le curseur quitte le petit popup pour survoler la fenêtre parente.2no_focus_fallbackgeneraltrueEmpêche le focus clavier de s'enrouler ou de se rabattre sur des fenêtres non désirées, stabilisant la discipline de focus globale.25.2 Implémentation des surcharges windowrulev2 cibléesLa solution technique la plus efficace et documentée par la communauté pour résoudre les problèmes de focus des popups GTK et JetBrains 13 consiste à utiliser la règle stayfocused. Ces règles doivent cibler l'expression régulière de classe (class:) ou de titre (title:) identifiée à l'étape 4.3.Règle 1 : Forcer le statut flottant (float)Extrait de codewindowrulev2 = float, CLASS_OU_TITRE_REGEX
L'application de la règle float est cruciale car elle garantit que le petit popup ou le dialogue transitoire est traité comme une surface flottante, l'empêchant d'être géré par la logique de carrelage (tiling) du compositeur, qui pourrait entraîner des problèmes de positionnement ou de dimensionnement.12Règle 2 : Empêcher le vol de focus initial (noinitialfocus)Extrait de codewindowrulev2 = noinitialfocus, CLASS_OU_TITRE_REGEX
Cette règle est hautement recommandée pour traiter les conditions de course (race conditions). Dans l'environnement Wayland, la création et le focus des fenêtres sont des opérations asynchrones. Si Hyprland focalise instantanément la nouvelle fenêtre transitoire avant que l'application GTK ne puisse établir son grab, des artefacts visuels ou des dysfonctionnements peuvent survenir. noinitialfocus 14 permet à l'application mère de gérer la transition du focus de manière contrôlée.Règle 3 : Application de la rétention de focus (stayfocused)Extrait de codewindowrulev2 = stayfocused, CLASS_OU_TITRE_REGEX
Ceci est le correctif fondamental.13 La propriété stayfocused force la fenêtre à conserver le focus clavier, neutralisant ainsi la logique agressive de input:follow_mouse d'Hyprland lorsque le curseur se déplace. En forçant la rétention du focus par le popover, on garantit que l'application GTK conserve la saisie d'entrée requise jusqu'à ce que le clic externe soit délivré, permettant ainsi à la fonction autohide de s'exécuter correctement.L'obligation d'utiliser ces trois règles spécifiques (float, noinitialfocus, stayfocused) pour un comportement standard de menu contextuel démontre clairement qu'Hyprland, par sa politique par défaut, s'écarte des normes protocolaires attendues pour la gestion des surfaces transitoires. Le développeur doit fondamentalement patcher la politique du gestionnaire de fenêtres pour restaurer la conformité protocolaire nécessaire à la boîte à outils GTK4.5.3 Stratégies de ciblage complexesPour les applications qui créent de nombreux popups ou pour les cas où le ciblage doit être appliqué à un ensemble d'applications, l'utilisation de balises (tag) peut simplifier la configuration, comme illustré dans le contexte des IDE JetBrains (qui rencontrent des problèmes similaires aux applications GTK).13Extrait de code# 1. Baliser toutes les fenêtres de la classe souhaitée (ex: JetBrains)
windowrulev2 = tag jb, class:^jetbrains-.+$

# 2. Appliquer les règles de focus à la balise
windowrulev2 = stayfocused, tag:jb
windowrulev2 = noinitialfocus, tag:jb
Cette approche permet de garantir que toutes les fenêtres transitoires générées par l'application cible bénéficient de la rétention de focus, réparant ainsi le comportement de fermeture automatique.Tableau 2 : Surcharges windowrulev2 essentielles pour les Popups WaylandRègleEffetNécessitéRaisonnementSourcefloatTraite la fenêtre comme flottante.ObligatoireEmpêche l'interférence de la logique de carrelage avec la position et le dimensionnement des menus.12stayfocusedForce la rétention du focus clavier.Obligatoire (Correctif principal)Neutralise input:follow_mouse, respecte la saisie GTK et permet à set_autohide de fonctionner.13noinitialfocusDésactive le focus initial.Hautement RecommandéPrévient les conditions de course et permet à l'application de mieux gérer la transition du focus.14VI. Conclusion et Trajectoires de Développement FuturesLa création d'une fenêtre gtk4-rs qui se ferme automatiquement lors d'un clic externe sous Hyprland est un problème résolu, mais il nécessite une intervention bidirectionnelle combinant l'implémentation client et la configuration du compositeur.L'analyse démontre que l'implémentation du comportement de menu idéal repose sur le widget GtkPopover et l'appel explicite de popover.set_autohide(true). Cette API communique au système Wayland la nécessité d'une saisie de focus temporaire.Cependant, Hyprland, en raison de ses politiques agressives de suivi du curseur, ignore ce contrat protocolaire pour les fenêtres flottantes et transitoires. Cela entraîne un vol de focus (même en mode follow_mouse = 2) et provoque le symptôme de la fenêtre parente verrouillée.La solution technique robuste impose l'application de règles de fenêtre ciblées dans hyprland.conf, notamment l'effet stayfocused, combiné à float et noinitialfocus. Ce déploiement de règles ciblées représente un patch de politique pour pallier la gestion incomplète des surfaces transitoires de xdg-shell par Hyprland dans le contexte du suivi de la souris.Il est important de noter que ce dysfonctionnement est reconnu comme une régression dans la communauté Hyprland.4 Les développeurs d'applications doivent continuer à surveiller les mises à jour d'Hyprland. Idéalement, les futures versions du compositeur Wayland devraient respecter de manière native les saisies de focus établies par les clients pour les popups sans nécessiter de surcharges explicites via windowrulev2. En attendant, la combinaison d'une implémentation GtkPopover correcte en gtk4-rs et des règles stayfocused dans Hyprland constitue la seule garantie d'un comportement stable et conforme à l'expérience utilisateur attendue.
